<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dutluk Mini Bulmaca</title>
  <link rel="icon" href="dut2.png" type="image/x-icon" />
  <style>
    html, body {
      overflow: hidden; /* Prevent scrolling entirely */
      height: 100vh; /* Full viewport height */
      margin: 0;
      padding: 0;
      position: fixed; /* Lock position */
      width: 100%; 
      top: 0;
      left: 0;
    }
    body {
      font-family: sans-serif;
      padding: 1rem;
      box-sizing: border-box; /* Include padding in height calculation */
      overflow-y: auto; /* Allow internal scrolling within body if needed */
      overflow-x: hidden; /* No horizontal scroll */
    }
    .grid {
      display: grid;
      gap: 2px;
      column-gap: 4px;
    }
    .cell {
      width: 40px;
      height: 40px;
      border: 1px solid #aaa;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      font-size: 1.2rem;
      cursor: pointer;
      background: white;
    }
    .cell.black {
      background: black;
    }
    .cell.selected {
      background: #facc15 !important; /* yellow-400 */
    }
    .cell.highlighted-word {
      background: #93c5fd; /* blue-300 */
    }
    .cell.error {
      background: #f87171 !important; /* red-400 */
      color: white;
    }
    .clues {
      margin-top: 1rem;
    }
    .clues h3 {
      margin-bottom: 0.5rem;
    }
    .clues li:not(.highlighted-clue) {
      display: none; /* Hide clues that are NOT highlighted */
    }
    .clues li.highlighted-clue {
      background: #bfdbfe; /* blue-200 */
      font-weight: bold;
      display: list-item; /* Ensure highlighted clue is visible */
    }
    #timeDiv {
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 1rem;
    }
    #dateText {
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 0.5rem;
    }
    /* Mobile responsive styles */
    @media (max-width: 768px) {
      body {
        padding: 0.5rem;
      }
      
      .grid {
        width: 95%;
        max-width: 400px;
        margin: 0 auto;
        aspect-ratio: 1;
        grid-template-columns: repeat(var(--grid-size), 1fr) !important;
      }
      
      .cell {
        width: auto !important;
        height: auto !important;
        aspect-ratio: 1;
        font-size: min(1.2rem, 4vw);
      }
      
      h1 {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }
      
      #dateText {
        font-size: 0.8rem;
      }
      
      #timeDiv {
        font-size: 1rem;
        margin-bottom: 0.5rem;
      }
      
      #clue {
        margin-top: 0.5rem;
        font-size: 1rem;
        max-width: 95%;
      }
    }
    .modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(7px);
    }
    .modal-content {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      text-align: center;
    }
    #clue {
      margin-top: 1rem;
      font-size: 1.2rem;
      font-weight: bold;
      color: #1e40af; /* blue-800 */
    }
    /* Hidden input field for mobile keyboard focus */
    #hiddenInput {
      position: fixed;
      top: -1000px; /* Off-screen but not too far */
      left: 0;
      opacity: 0.01; /* Very transparent but not completely invisible */
      width: 1px;
      height: 1px;
      border: none;
      background: transparent;
      color: transparent;
      z-index: -1;
      /* Prevent iOS zoom on focus */
      font-size: 16px;
      /* Prevent focus loss on cell clicks */
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <div id="startModal" class="modal">
    <div class="modal-content">
      <h2>Ready to play?</h2>
      <button id="startButton" onclick="startGame()">Start Crossword</button>
    </div>
  </div>

  <div id="successModal" class="modal" style="display:none">
    <div class="modal-content">
      <h2 id="congrats">ðŸŽ‰ Crossword Solved!</h2>
      <p><span id="youFinishedIn">You finished in</span> <span id="finalTime"></span>!</p>
       <button id="successOk" onclick="closeSuccessModal()">Close</button>
    </div>
  </div>

  <div id="errorModal" class="modal" style="display:none">
    <div class="modal-content">
      <h2 id="oops">Oops! Keep Trying!</h2>
      <p id="dontWorry">It looks like there are still some mistakes. Don't worry, you'll get it!</p>
      <button id="keepGoing" onclick="closeErrorModal()">Keep Going</button>
    </div>
  </div>

  <h1 id="title">Mini Crossword</h1>
  <p id="dateText"><span id="today"></span></p>
  <div id="timeDiv"><span id="timerName">Time</span>: <span id="timer">00:00</span></div>
  <div style="gap: 2rem">
    <div id="grid"></div>
  </div>
  <div id="clue"></div>
  <p><span id="by">prepared by</span> <span id="author"></span></p>

  <input type="text" id="hiddenInput" autofocus autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="text" />

  <!-- Add a visible button for iOS users to tap and focus the input -->
  <div id="iosKeyboardTrigger" style="position: fixed; bottom: 20px; right: 20px; background: #007AFF; color: white; padding: 10px 15px; border-radius: 20px; font-size: 14px; cursor: pointer; z-index: 1000; display: none;">
    ðŸ“± Tap to type
  </div>

  <div id="backlogIndicator" style="font-size: 0.9rem; color: #666; margin-bottom: 0.5rem; display: none;"></div>

  <script>
    let puzzleDate; // Will be set dynamically to the latest available puzzle date
    
    const lang = new URLSearchParams(window.location.search).get('lang') || 'tr';

    let allCellsFilledOnce = false; // Track if all cells have been filled at least once
    
    // Simple XOR decryption function (matches encrypt.html)
    function simpleDecrypt(encryptedText) {
      const key = 42; // Same key as in encrypt.html
      return encryptedText.split('').map(char => 
        String.fromCharCode(char.charCodeAt(0) ^ key)
      ).join('');
    }
    
    // Function to process puzzle text (handle both plain and encrypted content)
    function processPuzzleText(rawText) {
      const text = rawText.trim();
      
      // Check if content is encrypted
      if (text.startsWith('[ENCRYPTED]')) {
        console.log("Detected encrypted content, decrypting...");
        const encryptedContent = text.substring('[ENCRYPTED]\n'.length);
        const decryptedContent = simpleDecrypt(encryptedContent);
        console.log("Content decrypted successfully");
        return decryptedContent;
      } else {
        console.log("Processing plain text content");
        return text;
      }
    }

    // Function to get puzzle data from override or find latest puzzle
    async function getOrFindPuzzleData() {
      // Check for crossword override parameter
      const urlParams = new URLSearchParams(window.location.search);
      const crosswordOverride = urlParams.get('crosswordOverride');
      
      if (crosswordOverride) {
        console.log("Using crossword override data from URL parameter");
        try {
          const decodedData = decodeURIComponent(crosswordOverride);
          return {
            isOverride: true,
            content: decodedData,
            date: new Date().toISOString().slice(0, 10) // Use today's date for display
          };
        } catch (error) {
          console.error("Error decoding crossword override data:", error);
          // Fall back to normal puzzle loading
        }
      }
      
      // Normal puzzle loading - find latest available
      const puzzleDate = await findLatestPuzzle();
      return {
        isOverride: false,
        date: puzzleDate
      };
    }

    // Function to find the latest available puzzle file
    async function findLatestPuzzle() {
      const currentDate = new Date();
      
      // Try up to 30 days back
      for (let i = 0; i < 30; i++) {
        const testDate = new Date(currentDate);
        testDate.setDate(currentDate.getDate() - i);
        const dateString = testDate.toISOString().slice(0, 10);
        
        try {
          const response = await fetch(`${lang}/${dateString}.txt`);
          if (response.ok) {
            console.log(`Found puzzle file for date: ${dateString}`);
            return dateString;
          }
        } catch (error) {
          console.log(`No puzzle file found for ${dateString}`);
        }
      }
      
      // Fallback to today's date if nothing found
      return currentDate.toISOString().slice(0, 10);
    } 
    const hiddenInput = document.getElementById("hiddenInput");
    const iosKeyboardTrigger = document.getElementById("iosKeyboardTrigger");

    // Show iOS keyboard trigger button on iOS devices
    if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
      iosKeyboardTrigger.style.display = 'block';
      iosKeyboardTrigger.onclick = () => {
        hiddenInput.focus();
        hiddenInput.click();
        iosKeyboardTrigger.style.display = 'none';
        // Ensure no scroll after focus
        setTimeout(() => window.scrollTo(0, 0), 10);
      };
      
      // Also add touch event to the trigger for better iOS handling
      iosKeyboardTrigger.addEventListener('touchend', (e) => {
        e.preventDefault();
        hiddenInput.focus();
        hiddenInput.click();
        iosKeyboardTrigger.style.display = 'none';
        // Ensure no scroll after focus
        setTimeout(() => window.scrollTo(0, 0), 10);
      });
    }

    // Get localization json and load puzzle
    Promise.all([
      fetch(`localization/${lang}.json`).then(res => res.json()),
      getOrFindPuzzleData()
    ]).then(([localizationData, puzzleData]) => {
      // Set the global puzzleDate variable for use in completion checking
      puzzleDate = puzzleData.date;
      
      // Handle localization
      document.title = localizationData.title;
      const options = { year: 'numeric', month: 'long', day: 'numeric' };
      const formattedDate = new Date(puzzleData.date).toLocaleDateString(lang, options);
      document.getElementById("title").textContent = `${localizationData.title}`;
      document.getElementById("today").textContent = formattedDate;
      document.getElementById("startModal").querySelector("h2").textContent = localizationData.readyToPlay;
      document.getElementById("successModal").querySelector("h2").textContent = localizationData.successTitle;
      document.getElementById("errorModal").querySelector("h2").textContent = localizationData.errorTitle;
      document.getElementById("errorModal").querySelector("p").textContent = localizationData.errorMessage;
      document.getElementById("startButton").textContent = localizationData.startGame;
      document.getElementById("by").textContent = localizationData.by;
      document.getElementById("timerName").textContent = localizationData.time;
      document.getElementById("oops").textContent = localizationData.oopsKeepTrying;
      document.getElementById("dontWorry").textContent = localizationData.stillMistakes;
      document.getElementById("keepGoing").textContent = localizationData.keepGoing;
      document.getElementById("congrats").textContent = localizationData.crosswordSolved;
      document.getElementById("youFinishedIn").textContent = localizationData.youFinishedIn;
      document.getElementById("successOk").textContent = localizationData.successOk;
      console.log("Localization loaded:", localizationData);

      // Use override data if available, otherwise fetch from file
      if (puzzleData.isOverride) {
        return Promise.resolve(puzzleData.content);
      } else {
        // Load puzzle data from file
        return fetch(`${lang}/${puzzleData.date}.txt`);
      }
    }).then(dataOrResponse => {
      let puzzleTextPromise;
      
      if (typeof dataOrResponse === 'string') {
        // It's override data, use directly
        puzzleTextPromise = Promise.resolve(dataOrResponse);
      } else {
        // It's a fetch response
        if (!dataOrResponse.ok) {
          throw new Error(`HTTP error! status: ${dataOrResponse.status}`);
        }
        puzzleTextPromise = dataOrResponse.text();
      }
      
      return puzzleTextPromise;
    }).then(text => {
      console.log("Fetched puzzle data:", text);
      const processedText = processPuzzleText(text);
      console.log("Processed puzzle data:", processedText);
      const lines = processedText.trim().split("\n");
      const author = lines[0].split(": ")[1];
      document.getElementById("author").textContent = author;

      gridSize = parseInt(lines[1].split(": ")[1]);
      const gridLines = lines.slice(2, 2 + gridSize);
      if (gridLines.length !== gridSize || gridLines.some(l => l.length !== gridSize)) {
        console.error("Grid size mismatch!", { expected: gridSize, actualRows: gridLines.length, actualCols: gridLines.map(l=>l.length) });
        alert("Grid size mismatch");
        throw new Error("Grid size mismatch");
      }

      grid = gridLines.map(l => l.split(""));
      answers = Array(gridSize).fill(null).map(() => Array(gridSize).fill(""));
      console.log("Initial grid loaded:", grid);
      console.log("Initial answers array:", answers);

      // If 0,0 is a black cell, set selected to the first white cell
      while (selected.row < gridSize && selected.col < gridSize && grid[selected.row][selected.col] === '-') {
        selected.col++;
        if (selected.col >= gridSize) {
          selected.col = 0;
          selected.row++;
        }
      }
      if (selected.row >= gridSize) {
        console.error("No valid starting cell found in the grid.");
        alert("No valid starting cell found in the grid.");
        return;
      }

      // Populate original clues data from the file
      lines.slice(2 + gridSize).forEach(line => {
        if (!line.includes(": ")) return;
        const [pos, clue] = line.split(": ");
        const dir = pos.startsWith("H") ? "H" : "V";
        const id = pos.slice(1);
        cluesData[dir][id] = clue;
      });
      console.log("Raw clues data loaded:", cluesData);

      mapCluePositions(); // Map clue numbers to grid positions after grid is loaded
      renderGrid(); // Render grid and manage clue visibility
    }).catch(error => {
      console.error("Error loading crossword data:", error);
      alert("Failed to load crossword puzzle. Make sure the puzzle file exists and is correctly formatted.");
    });

    let selected = { row: 0, col: 0 };
    let currentDirection = 'across'; // 'across' or 'down'
    let answers = [];
    let gridSize = 0;
    let grid = [];
    let cluesData = { H: {}, V: {} };
    let cluePositions = {
      across: {},
      down: {}
    };
    let timerInterval;
    let startTime;

    console.log("Script loaded.");

    function focusHiddenInput() {
      // Use a timeout to ensure focus after other DOM manipulations
      setTimeout(() => {
        try {
          // Only focus if not already focused to prevent keyboard flicker
          if (!hiddenInput.matches(':focus')) {
            hiddenInput.focus();
            // For iOS, sometimes we need to trigger a click event
            if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
              hiddenInput.click();
            }
          }
          // Always ensure no scroll after focus
          window.scrollTo(0, 0);
        } catch (e) {
          console.log('Focus failed:', e);
        }
      }, 100);
    }

    function startTimer() {
      startTime = Date.now();
      timerInterval = setInterval(() => {
        const now = Date.now();
        const diff = Math.floor((now - startTime) / 1000);
        const min = String(Math.floor(diff / 60)).padStart(2, '0');
        const sec = String(diff % 60).padStart(2, '0');
        document.getElementById("timer").textContent = `${min}:${sec}`;
      }, 1000);
      console.log("Timer started.");
    }

    function stopTimer() {
      clearInterval(timerInterval);
      console.log("Timer stopped.");
    }

    function showSuccessModal() {
      stopTimer();
      // Blur the hidden input when a modal is shown
      hiddenInput.blur();
      const diff = Math.floor((Date.now() - startTime) / 1000);
      const min = String(Math.floor(diff / 60)).padStart(2, '0');
      const sec = String(diff % 60).padStart(2, '0');
      document.getElementById("finalTime").textContent = `${min}:${sec}`;
      document.getElementById("successModal").style.display = 'flex';
      console.log(`Success modal shown. Final time: ${min}:${sec}`);
    }

    function closeSuccessModal() {
      document.getElementById("successModal").style.display = 'none';
      focusHiddenInput(); // Re-focus hidden input after modal closes
    }

    function showErrorModal() {
      // Blur the hidden input when a modal is shown
      hiddenInput.blur();
      document.getElementById("errorModal").style.display = 'flex';
      console.log("Error modal shown.");
    }

    function closeErrorModal() {
      document.getElementById("errorModal").style.display = 'none';
      focusHiddenInput(); // Re-focus hidden input after modal closes
    }

    function startGame() {
      document.getElementById("startModal").style.display = 'none';
      startTimer();
      focusHiddenInput(); // Focus hidden input when game starts
      console.log("Game started.");
    }

    // Function to map clue numbers to grid positions (based on standard crossword numbering)
    function mapCluePositions() {
      let currentAcrossClueNum = 1;
      let currentDownClueNum = 1;

      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (grid[r][c] !== '-') { // If it's a white cell
            let isStartOfAcrossWord = (c === 0 || grid[r][c - 1] === '-');
            if (isStartOfAcrossWord) {
              cluePositions.across[`${r},${c}`] = String(currentAcrossClueNum);
              currentAcrossClueNum++;
            }
          }
        }
      }
      for (let c = 0; c < gridSize; c++) {
        for (let r = 0; r < gridSize; r++) {
          if (grid[r][c] !== '-') { // If it's a white cell
            let isStartOfDownWord = (r === 0 || grid[r - 1][c] === '-');
            if (isStartOfDownWord) {
              cluePositions.down[`${r},${c}`] = String(currentDownClueNum);
              currentDownClueNum++;
            }
          }
        }
      }
      console.log("Clue positions mapped:", { across: cluePositions.across, down: cluePositions.down });
    }

    function getWordInfo(row, col, direction) {
      console.log(`getWordInfo called for (${row}, ${col}) direction: ${direction}`);
      let startRow = row;
      let startCol = col;
      let endRow = row;
      let endCol = col;

      if (direction === 'across') {
        // Find start of the word
        while (startCol > 0 && grid[row][startCol - 1] !== '-') {
          startCol--;
        }
        // Find end of the word
        while (endCol < gridSize - 1 && grid[row][endCol + 1] !== '-') {
          endCol++;
        }
      } else { // 'down'
        // Find start of the word
        while (startRow > 0 && grid[startRow - 1][col] !== '-') {
          startRow--;
        }
        // Find end of the word
        while (endRow < gridSize - 1 && grid[endRow + 1][col] !== '-') {
          endRow++;
        }
      }

      let wordCells = [];
      let clueId = null;

      if (direction === 'across') {
        for (let c = startCol; c <= endCol; c++) {
          wordCells.push({ r: row, c: c });
        }
        clueId = cluePositions.across[`${startRow},${startCol}`] || null;

      } else { // 'down'
        for (let r_word = startRow; r_word <= endRow; r_word++) {
          wordCells.push({ r: r_word, c: col });
        }
        clueId = cluePositions.down[`${startRow},${startCol}`] || null;
      }
      console.log(`Word info for (${row}, ${col}) ${direction}: Start(${startRow},${startCol}), End(${endRow},${endCol}), Clue ID: ${clueId}`);
      return { wordCells, clueId };
    }

    function toUpperCaseWithLocale(str) {
      // Convert to uppercase based on the current locale
      return str.toLocaleUpperCase(lang === 'tr' ? 'tr-TR' : 'en-US');
    }


    function renderGrid() {
      console.log(`renderGrid called. Selected: (${selected.row}, ${selected.col}), Direction: ${currentDirection}`);
      const gridEl = document.getElementById("grid");
      gridEl.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;
      gridEl.className = "grid";
      gridEl.innerHTML = "";

      // Set CSS custom property for mobile responsive grid sizing
      document.documentElement.style.setProperty('--grid-size', gridSize);

      document.querySelectorAll('.clues li').forEach(el => {
        el.classList.remove('highlighted-clue');
        el.style.display = 'none';
      });

      const { wordCells: highlightedWordCells, clueId: activeClueId } = getWordInfo(selected.row, selected.col, currentDirection);
      console.log("Highlighted word cells:", highlightedWordCells);
      console.log("Active clue ID from getWordInfo:", activeClueId);


      grid.forEach((row, r) => {
        row.forEach((cell, c) => {
          const div = document.createElement("div");
          let classList = ["cell"];
          if (cell === "-") classList.push("black");

          const isHighlightedWordCell = highlightedWordCells.some(wc => wc.r === r && wc.c === c);
          if (isHighlightedWordCell) {
            classList.push("highlighted-word");
          }

          if (r === selected.row && c === selected.col) {
            classList.push("selected");
          }
          div.className = classList.join(" ");

          div.dataset.row = r;
          div.dataset.col = c;
          div.textContent = answers[r][c];

          div.onclick = () => {
            console.log(`Cell clicked: (${r}, ${c}). Current selected: (${selected.row}, ${selected.col})`);
            if (grid[r][c] === "-") {
              console.log("Clicked black cell, ignored.");
              return;
            }

            if (selected.row === r && selected.col === c) {
              currentDirection = currentDirection === 'across' ? 'down' : 'across';
              console.log(`Switched direction to: ${currentDirection}`);
            } else {
              selected = { row: r, col: c };
              console.log(`New cell selected: (${selected.row}, ${selected.col})`);

              const acrossWordInfo = getWordInfo(r, c, 'across');
              const downWordInfo = getWordInfo(r, c, 'down');

              const hasAcrossWord = acrossWordInfo.wordCells.length > 0 && acrossWordInfo.clueId;
              const hasDownWord = downWordInfo.wordCells.length > 0 && downWordInfo.clueId;

              if (currentDirection === 'across' && hasAcrossWord) {
                console.log("Keeping direction across due to valid word.");
              } else if (currentDirection === 'down' && hasDownWord) {
                console.log("Keeping direction down due to valid word.");
              } else if (hasAcrossWord) {
                currentDirection = 'across';
                console.log("Changed direction to across (only valid word).");
              } else if (hasDownWord) {
                currentDirection = 'down';
                console.log("Changed direction to down (only valid word).");
              } else {
                currentDirection = 'across';
                console.log("Defaulting direction to across (no valid words found).");
              }
            }
            renderGrid();
            
            // Simplified focus handling - let iOS show the button when needed
            if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
              // For iOS, try to maintain focus but don't be aggressive about it
              setTimeout(() => {
                hiddenInput.focus();
              }, 50);
            } else {
              // For other devices, simple focus check
              if (!hiddenInput.matches(':focus')) {
                setTimeout(() => {
                  hiddenInput.focus();
                }, 10);
              }
            }
          };

          gridEl.appendChild(div);
        });
      });

      function getNthItemUsingEntries(direction, n) {
        const entries = Object.entries(direction === 'across' ? cluesData.H : cluesData.V);
        if (n >= 0 && n < entries.length) {
          return entries[n][1];
        }
        return undefined;
      }

      if (activeClueId) {
        const clue = getNthItemUsingEntries(currentDirection, activeClueId-1);
        document.getElementById("clue").innerText = clue;
      }

      // Handle both input and keydown events for better mobile/desktop compatibility
      hiddenInput.oninput = (e) => {
        console.log(`Input event on hidden input: ${e.target.value}. Current selected: (${selected.row}, ${selected.col}), Direction: ${currentDirection}`);
        const r = selected.row;
        const c = selected.col;

        if (grid[r][c] === "-") {
          console.log("Input on black cell, ignored.");
          hiddenInput.value = '';
          return;
        }

        const inputValue = e.target.value;
        if (inputValue && inputValue.length > 0) {
          const lastChar = inputValue[inputValue.length - 1];
          if (/[a-zA-Z\u00C0-\u024F\u1E00-\u1EFF]/.test(lastChar)) {
            answers[r][c] = toUpperCaseWithLocale(lastChar);
            console.log(`Entered '${toUpperCaseWithLocale(lastChar)}' at (${r}, ${c}). Answers[${r}][${c}] = '${answers[r][c]}'`);

            if (checkIfAllFilled()) {
              console.log("All cells are filled. Checking if complete...");
              if (isPuzzleComplete()) {
                console.log("Crossword is complete!");
                showSuccessModal();
              } else {
                console.log("Crossword is filled but incorrect.");
                if (!allCellsFilledOnce) {
                  showErrorModal();
                }
                allCellsFilledOnce = true;
              }
            }
            if (currentDirection === 'across') {
              moveToNextEnterableCell(r, c, 1, 0);
            } else {
              moveToNextEnterableCell(r, c, 0, 1);
            }
            renderGrid();
          }
        }
        // Clear the hidden input value after processing
        hiddenInput.value = '';
      };

      hiddenInput.onkeydown = (e) => {
        console.log(`Keydown event on hidden input: ${e.key}. Current selected: (${selected.row}, ${selected.col}), Direction: ${currentDirection}`);
        const r = selected.row;
        const c = selected.col;

        if (grid[r][c] === "-") {
          console.log("Key press on black cell, ignored.");
          e.preventDefault();
          return;
        }

        if (e.key === "Backspace") {
          e.preventDefault();
          console.log(`Backspace pressed at (${r}, ${c}). Current value: '${answers[r][c]}'`);
          if (answers[r][c] !== "") {
            answers[r][c] = "";
            console.log(`Cleared cell (${r}, ${c}).`);
          } else {
            console.log(`Cell (${r}, ${c}) was empty, moving to previous enterable cell.`);
            if (currentDirection === 'across') {
              moveToPreviousEnterableCell(r, c, 1, 0);
            } else {
              moveToPreviousEnterableCell(r, c, 0, 1);
            }
          }
          renderGrid();
        } else if (e.key === "ArrowRight") {
            currentDirection = 'across';
            moveToNextWhiteCell(r, c, 1, 0);
            renderGrid();
        } else if (e.key === "ArrowLeft") {
            currentDirection = 'across';
            moveToNextWhiteCell(r, c, -1, 0);
            renderGrid();
        } else if (e.key === "ArrowUp") {
            currentDirection = 'down';
            moveToNextWhiteCell(r, c, 0, -1);
            renderGrid();
        } else if (e.key === "ArrowDown") {
            currentDirection = 'down';
            moveToNextWhiteCell(r, c, 0, 1);
            renderGrid();
        }
      };
    }

    function checkIfComplete() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (grid[r][c] === "-") continue;
          if (toUpperCaseWithLocale(answers[r][c]) !== toUpperCaseWithLocale(grid[r][c])) {
            console.log(`Mismatch at (${r}, ${c}): Expected '${grid[r][c]}', Got '${answers[r][c]}'`);
            return false;
          }
        }
      }
      return true;
    }

    function checkIfCompleteWithoutSpecialCharacters() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (grid[r][c] === "-") continue;
          
          let expectedChar = normalizeForComparison(toUpperCaseWithLocale(grid[r][c]));
          let enteredChar = normalizeForComparison(toUpperCaseWithLocale(answers[r][c]));
          
          if (enteredChar !== expectedChar) {
            console.log(`Mismatch (normalized) at (${r}, ${c}): Expected '${grid[r][c]}' (${expectedChar}), Got '${answers[r][c]}' (${enteredChar})`);
            return false;
          }
        }
      }
      return true;
    }

    // Check if puzzle is complete, allowing fallback for older puzzles
    function isPuzzleComplete() {
      const exactMatch = checkIfComplete();
      
      // For puzzles dated July 10, 2025 or earlier, also allow Turkish/English equivalents
      if (!exactMatch && shouldAllowTurkishEnglishEquivalents()) {
        const normalizedMatch = checkIfCompleteWithoutSpecialCharacters();
        if (normalizedMatch) {
          console.log("Puzzle completed using Turkish/English letter equivalents (legacy support)");
        }
        return normalizedMatch;
      }
      
      return exactMatch;
    }

    // Check if we should allow Turkish/English letter equivalents based on puzzle date
    function shouldAllowTurkishEnglishEquivalents() {
      try {
        // Get the puzzle date from the puzzleDate variable or fallback
        const puzzleDateStr = puzzleDate || new Date().toISOString().slice(0, 10);
        const puzzleDateObj = new Date(puzzleDateStr);
        const cutoffDate = new Date('2025-07-10');
        
        return puzzleDateObj <= cutoffDate;
      } catch (error) {
        console.log('Error checking puzzle date for Turkish equivalents:', error);
        return false; // Default to strict checking if date parsing fails
      }
    }

    // Normalize Turkish and English letter equivalents for comparison
    function normalizeForComparison(char) {
      const turkishToEnglish = {
        'Åž': 'S', 'ÅŸ': 's',
        'Ä°': 'I', 'Ä±': 'i', 'I': 'I',
        'Äž': 'G', 'ÄŸ': 'g',
        'Ãœ': 'U', 'Ã¼': 'u',
        'Ã–': 'O', 'Ã¶': 'o',
        'Ã‡': 'C', 'Ã§': 'c'
      };
      
      return turkishToEnglish[char] || char;
    }

    function checkIfAllFilled() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (grid[r][c] !== "-" && answers[r][c] === "") {
            console.log(`Cell (${r}, ${c}) is empty.`);
            return false;
          }
        }
      }
      console.log("All white cells are filled.");
      return true;
    }

    function moveToNextWhiteCell(row, col, dx, dy) {
      console.log(`moveToNextWhiteCell from (${row}, ${col}) with dx:${dx}, dy:${dy}`);
      let r = row;
      let c = col;
      let originalR = row;
      let originalC = col;

      do {
        r += dy;
        c += dx;
        if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) {
            console.log(`Hit boundary at (${r}, ${c}). Staying at original.`);
            selected = { row: originalR, col: originalC };
            return;
        }
      } while (grid[r][c] === "-");

      console.log(`Moved to next white cell: (${r}, ${c})`);
      selected = { row: r, col: c };
    }

    function moveToNextEnterableCell(row, col, dx, dy) {
      console.log(`moveToNextEnterableCell from (${row}, ${col}) with dx:${dx}, dy:${dy}`);
      let nextR = row + dy;
      let nextC = col + dx;

      while (nextR < gridSize && nextC < gridSize && nextR >= 0 && nextC >= 0) {
        if (grid[nextR][nextC] !== "-" && answers[nextR][nextC] === "") {
          selected = { row: nextR, col: nextC };
          console.log(`Moved to next enterable cell in current word: (${selected.row}, ${selected.col})`);
          return;
        }
        nextR += dy;
        nextC += dx;
      }

      console.log("No next enterable cell in current word. Searching for next word.");
      if (currentDirection === 'across') {
        for (let r_new = row; r_new < gridSize; r_new++) {
          for (let c_new = (r_new === row ? col + 1 : 0); c_new < gridSize; c_new++) {
            if (grid[r_new][c_new] !== '-' && answers[r_new][c_new] === "") {
              selected = { row: r_new, col: c_new };
              console.log(`Moved to start of next across word: (${selected.row}, ${selected.col})`);
              return;
            }
          }
        }
      } else { // 'down'
        for (let c_new = col; c_new < gridSize; c_new++) {
          for (let r_new = (c_new === col ? row + 1 : 0); r_new < gridSize; r_new++) {
            if (grid[r_new][c_new] !== '-' && answers[r_new][c_new] === "") {
              selected = { row: r_new, col: c_new };
              console.log(`Moved to start of next down word: (${selected.row}, ${selected.col})`);
              return;
            }
          }
        }
      }
      console.log("No next enterable cell found in entire grid. Staying at current.");
      selected = { row: row, col: col };
    }

    function moveToPreviousEnterableCell(row, col, dx, dy) {
        console.log(`moveToPreviousEnterableCell from (${row}, ${col}) with dx:${dx}, dy:${dy}`);
        let prevR = row - dy;
        let prevC = col - dx;

        while (prevR >= 0 && prevC >= 0 && prevR < gridSize && prevC < gridSize) {
            if (grid[prevR][prevC] !== "-") {
                selected = { row: prevR, col: prevC };
                console.log(`Moved to previous enterable cell in current word: (${selected.row}, ${selected.col})`);
                return;
            }
            prevR -= dy;
            prevC -= dx;
        }

        console.log("No previous enterable cell in current word. Searching for end of previous word.");
        if (currentDirection === 'across') {
            for (let r_new = row; r_new >= 0; r_new--) {
                for (let c_new = (r_new === row ? col - 1 : gridSize - 1); c_new >= 0; c_new--) {
                    if (grid[r_new][c_new] !== '-') {
                        if (c_new === gridSize - 1 || grid[r_new][c_new + 1] === '-') {
                             selected = { row: r_new, col: c_new };
                             console.log(`Moved to end of previous across word: (${selected.row}, ${selected.col})`);
                             return;
                        }
                    }
                }
            }
        } else { // 'down'
            for (let c_new = col; c_new >= 0; c_new--) {
                for (let r_new = (c_new === col ? row - 1 : gridSize - 1); r_new >= 0; r_new--) {
                    if (grid[r_new][c_new] !== '-') {
                        if (r_new === gridSize - 1 || grid[r_new + 1][c_new] === '-') {
                            selected = { row: r_new, col: c_new };
                            console.log(`Moved to end of previous down word: (${selected.row}, ${selected.col})`);
                            return;
                        }
                    }
                }
            }
        }
        console.log("No previous word found in entire grid. Staying at current.");
        selected = { row: row, col: col };
    }

    // Prevent any scrolling and keep viewport locked at top
    function preventScroll() {
      window.scrollTo(0, 0);
    }

    // Multiple event listeners to prevent scrolling
    window.addEventListener('scroll', preventScroll, { passive: false });
    window.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });
    window.addEventListener('wheel', (e) => {
      e.preventDefault();
    }, { passive: false });

    // Prevent scroll on keyboard navigation
    window.addEventListener('keydown', (e) => {
      if (['Space', 'ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End'].includes(e.code)) {
        // Only prevent if not typing in our hidden input
        if (e.target !== hiddenInput) {
          e.preventDefault();
        }
      }
    });

    // Force scroll to top periodically (backup)
    setInterval(() => {
      if (window.scrollY !== 0) {
        window.scrollTo(0, 0);
      }
    }, 100);

    // Enhanced focus management for iOS
    document.addEventListener('focusout', (e) => {
      // If the hidden input loses focus and no modal is open, refocus it
      if (e.target === hiddenInput) {
        const modalsOpen = document.querySelector('.modal[style*="flex"]');
        if (!modalsOpen) {
          // For iOS, show the button again if focus is lost
          if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
            setTimeout(() => {
              iosKeyboardTrigger.style.display = 'block';
            }, 100);
          } else {
            // For other devices, try to refocus automatically
            setTimeout(() => {
              if (!hiddenInput.matches(':focus')) {
                hiddenInput.focus();
              }
            }, 50);
          }
        }
      }
    });

    // Initial focus on the hidden input after the page loads
    window.onload = focusHiddenInput;
  </script>
  <script>
    async function findAvailableDaysInFuture() {
      const currentDate = new Date();
      let availableDays = 0;
      let latestDate = null;
      
      // Try up to 30 days back
      for (let i = 0; i < 30; i++) {
        const testDate = new Date(currentDate);
        testDate.setDate(currentDate.getDate() - i);
        const dateString = testDate.toISOString().slice(0, 10);
        
        try {
          const response = await fetch(`${lang}/${dateString}.txt`);
          if (response.ok) {
            console.log(`Found puzzle file for date: ${dateString}`);
            if (!latestDate) {
              latestDate = dateString;
            }
            availableDays++;
          }
        } catch (error) {
          console.log(`No puzzle file found for ${dateString}`);
        }
      }
      
      // Update the backlog indicator
      return availableDays;
      
    }

    // Function to update the backlog indicator
    function updateBacklogIndicator(days) {
      const backlogElement = document.getElementById("backlogIndicator");
      if (backlogElement) {
        if (days > 0) {
          backlogElement.textContent = `${days} puzzle${days === 1 ? '' : 's'} available`;
          backlogElement.style.display = 'block';
        } else {
          backlogElement.style.display = 'none';
        }
      }
    }
    updateBacklogIndicator(findAvailableDaysInFuture())
  </script>
</body>
</html>